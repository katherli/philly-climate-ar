<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Philadelphia Climate Surface (1945–2024)</title>
<script src="https://cdn.tailwindcss.com"></script>
<style>
  html,body{margin:0;height:100%;background:#050508;font-family:Inter,system-ui,sans-serif}
  #wrap{height:100%;display:flex;align-items:center;justify-content:center}
  /* Ensure 17:11 paper fits inside the viewport without overflowing */
  #paper{
    position:relative;
    width: min(95vw, calc(95vh * (17/11)));
    height: auto;
    aspect-ratio: 17/11;
    background:#000;
    border:1px solid #222;
    box-shadow:0 0 40px rgba(0,0,0,.7);
    max-height: 95vh;
  }
  canvas{width:100%;height:100%;display:block}
  .hud{position:absolute;inset:0;pointer-events:none}
  .panel{pointer-events:auto}
</style>
</head>
<body>
<div id="wrap">
  <div id="paper">
    <canvas id="glCanvas"></canvas>
    <div class="hud flex flex-col justify-between p-6">
      <div class="flex justify-between gap-4">
        <div class="panel bg-black/65 backdrop-blur-md p-4 rounded-lg border border-white/10 text-white shadow-xl">
          <div class="text-xl font-semibold">Philadelphia Climate Tapestry</div>
          <div class="text-xs text-zinc-400">Yearly Temperature Anomaly • 1945–2024</div>
          <div id="yearLabel" class="mt-1 text-[11px] text-sky-400 font-mono uppercase">Loading…</div>
        </div>
      </div>
      <div class="flex justify-between items-end gap-4">
        <div class="panel bg-black/65 backdrop-blur-md p-4 rounded-lg border border-white/10 text-white shadow-xl">
          <div class="text-[10px] font-bold uppercase tracking-wider mb-2 text-zinc-300">Temp Anomaly Scale</div>
          <div class="w-40 h-2 rounded-sm bg-gradient-to-r from-[#0033ff] via-[#7020aa] to-[#ff3300]"></div>
          <div class="flex justify-between text-[9px] text-zinc-400 font-mono w-40 mt-1">
            <span>Colder</span><span>Baseline</span><span>Warmer</span>
          </div>
          <div id="baselineLabel" class="text-[10px] text-zinc-500 font-mono mt-2">Baseline: 1945–1975 mean</div>
        </div>
        <div class="panel">
          <div class="flex gap-2">
            <button id="pauseBtn"
              class="bg-zinc-700 text-white hover:bg-zinc-600 font-semibold py-2 px-4 rounded text-xs shadow-lg transition-colors">
              Pause
            </button>
            <button id="exportBtn"
              class="bg-white text-black hover:bg-zinc-200 font-semibold py-2 px-4 rounded text-xs shadow-lg transition-colors">
              Export 17" × 11" PNG
            </button>
            <button id="restartBtn"
              class="bg-sky-600 text-white hover:bg-sky-500 font-semibold py-2 px-4 rounded text-xs shadow-lg transition-colors">
              Restart
            </button>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Vertex shader: 17×11 plane displaced like cloth/water -->
<script id="vs" type="x-shader/x-vertex">
attribute vec2 aUV;

uniform mat4 u_proj, u_view;
uniform float u_time;
uniform float u_anomaly;     // 0..1 (current year, blended)
uniform float u_cumulative;  // 0..1 (running sum normalized)
uniform float u_heightScale; // global height scale
uniform float u_wind;        // 0..1 (normalized wind speed)
uniform float u_precip;      // 0..1 (normalized precipitation)

varying vec3 v_pos;
varying vec3 v_normal;
varying vec2 v_uv;
varying float v_anom;

mat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,-s,s,c);}

// Simplex noise 2D for organic spatial variation
vec3 permute(vec3 x){ return mod(((x*34.0)+1.0)*x, 289.0); }

float snoise(vec2 v){
  const vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);
  vec2 i  = floor(v + dot(v, C.yy));
  vec2 x0 = v - i + dot(i, C.xx);
  vec2 i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
  vec4 x12 = x0.xyxy + C.xxzz;
  x12.xy -= i1;
  i = mod(i, 289.0);
  vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0)) + i.x + vec3(0.0, i1.x, 1.0));
  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
  m = m*m; m = m*m;
  vec3 x = 2.0 * fract(p * C.www) - 1.0;
  vec3 h = abs(x) - 0.5;
  vec3 ox = floor(x + 0.5);
  vec3 a0 = x - ox;
  m *= 1.79284291400159 - 0.85373472095314 * (a0*a0 + h*h);
  vec3 g;
  g.x  = a0.x  * x0.x  + h.x  * x0.y;
  g.yz = a0.yz * x12.xz + h.yz * x12.yw;
  return 130.0 * dot(m, g);
}

float disp(vec2 p, float t, float an, float cum, float wind, float precip){
  // Amplitude based on anomaly and cumulative only
  float A = mix(0.05, 0.25, an) + cum * 0.12;
  
  // Add spatial noise for cloth-like behavior - different areas move differently
  vec2 noiseCoord = p * 0.2;
  float n1 = snoise(noiseCoord + vec2(t*0.1, 0.0));
  float n2 = snoise(noiseCoord * 1.3 - vec2(0.0, t*0.15));
  
  // Use noise to modulate phase and amplitude locally
  float localPhase = (n1 + n2) * 0.5;
  float localAmp = 0.7 + 0.3 * snoise(p * 0.15 + t * 0.08);
  
  // Lower frequencies (k) for fewer, larger ripples
  // Wind controls speed - very subtle speed variations
  float k1 = mix(0.6, 0.4, an), sp1 = 0.8 + wind * 0.15;
  float k2 = mix(0.8, 0.6, an), sp2 = 1.0 + wind * 0.2;
  float k3 = mix(0.9, 0.7, an), sp3 = 0.6 + wind * 0.1;

  // Smoother directional spread - evenly spaced rotations (120° apart)
  vec2 q1 = rot(0.00)  * p; 
  float w1 = sin(dot(q1, vec2(k1, k1*1.05)) - t*sp1 + localPhase*0.3);
  
  vec2 q2 = rot(2.09)  * p;  // 120° rotation for even distribution
  float w2 = sin(dot(q2, vec2(k2, k2*1.05)) - t*sp2 + localPhase*0.3);
  
  vec2 q3 = rot(4.19) * p;   // 240° rotation for even distribution
  float w3 = sin(dot(q3, vec2(k3, k3*1.05)) - t*sp3 + localPhase*0.3);
  
  // Mix 3 waves with balanced weights for smoother surface
  return A * localAmp * (w1 + 0.8*w2 + 0.6*w3);
}

void main(){
  v_uv = aUV;
  v_anom = u_anomaly;

  // Exact 17×11 world units for AR consistency (centered)
  vec2 plane = vec2(mix(-8.5, 8.5, aUV.x), mix(-5.5, 5.5, aUV.y));

  float t = u_time;
  
  // Large-scale billowing motion - entire fabric undulates
  float billow1 = sin(plane.x * 0.3 + t * 0.4) * cos(plane.y * 0.25 + t * 0.35);
  float billow2 = sin(plane.x * 0.4 - plane.y * 0.3 + t * 0.5);
  float billowHeight = (billow1 * 0.8 + billow2 * 0.5) * 0.3; // gentle large waves
  
  // Add small ripples on top
  float h  = disp(plane, t, u_anomaly, u_cumulative, u_wind, u_precip) + billowHeight;

  // Finite differences for smooth normals (use plane-space eps)
  float e = 0.05;
  float billow1x = sin((plane.x+e) * 0.3 + t * 0.4) * cos(plane.y * 0.25 + t * 0.35);
  float billow2x = sin((plane.x+e) * 0.4 - plane.y * 0.3 + t * 0.5);
  float billowHeightX = (billow1x * 0.8 + billow2x * 0.5) * 0.3;
  
  float billow1y = sin(plane.x * 0.3 + t * 0.4) * cos((plane.y+e) * 0.25 + t * 0.35);
  float billow2y = sin(plane.x * 0.4 - (plane.y+e) * 0.3 + t * 0.5);
  float billowHeightY = (billow1y * 0.8 + billow2y * 0.5) * 0.3;
  
  float hx = disp(plane + vec2(e,0.0), t, u_anomaly, u_cumulative, u_wind, u_precip) + billowHeightX;
  float hy = disp(plane + vec2(0.0,e), t, u_anomaly, u_cumulative, u_wind, u_precip) + billowHeightY;

  vec3 P  = vec3(plane.x, h*u_heightScale, plane.y);
  vec3 Px = vec3(plane.x+e, hx*u_heightScale, plane.y);
  vec3 Py = vec3(plane.x, hy*u_heightScale, plane.y+e);

  vec3 N = normalize(cross(Py-P, Px-P)); // right-handed

  v_pos = P;
  v_normal = N;

  gl_Position = u_proj * u_view * vec4(P,1.0);
}
</script>

<!-- Fragment shader: 2D fbm field color mapping + 3D lighting -->
<script id="fs" type="x-shader/x-fragment">
precision highp float;

varying vec3 v_pos;
varying vec3 v_normal;
varying vec2 v_uv;
varying float v_anom;

uniform vec3 u_lightDir;
uniform vec3 u_camPos;
uniform float u_time;
uniform float u_cumulative;

/* 2D simplex noise for field-based coloring */
vec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }

float snoise(vec2 v) {
    const vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);
    vec2 i  = floor(v + dot(v, C.yy));
    vec2 x0 = v - i + dot(i, C.xx);
    vec2 i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
    vec4 x12 = x0.xyxy + C.xxzz;
    x12.xy -= i1;
    i = mod(i, 289.0);
    vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0)) + i.x + vec3(0.0, i1.x, 1.0));
    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
    m = m*m; m = m*m;
    vec3 x = 2.0 * fract(p * C.www) - 1.0;
    vec3 h = abs(x) - 0.5;
    vec3 ox = floor(x + 0.5);
    vec3 a0 = x - ox;
    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0 + h*h);
    vec3 g;
    g.x  = a0.x  * x0.x  + h.x  * x0.y;
    g.yz = a0.yz * x12.xz + h.yz * x12.yw;
    return 130.0 * dot(m, g);
}

float fbm(vec2 p) {
    float v = 0.0;
    float a = 0.5;
    float freq = 1.0;
    for (int i = 0; i < 5; i++) {
        v += a * snoise(p * freq);
        freq *= 2.0;
        a *= 0.5;
    }
    return v;
}

void main(){
    // Use UV space for field generation (like the 2D version)
    vec2 uv = v_uv - 0.5;
    float aspect = 17.0 / 11.0;
    uv.x *= aspect;

    // Map anomaly to signed range
    float an = v_anom * 2.0 - 1.0;
    float cum = u_cumulative * 2.0 - 1.0;

    // Time scaling - later years move more aggressively
    float speed = mix(0.15, 0.6, clamp(u_cumulative, 0.0, 1.0));
    float t = u_time * speed;

    // Use height from displacement to drive color
    float h = v_pos.y; // height from the rippling surface
    
    // Warped fbm field but more subtle, let height lead
    vec2 base = uv * mix(1.8, 2.5, 0.5 + 0.5*an);
    vec2 warp = vec2(
        snoise(base * 0.5 + vec2(0.0, t*0.3)),
        snoise(base * 0.5 + vec2(t*0.3, 1.0))
    );
    vec2 p = base + warp * 0.3; // reduced warp strength

    float f1 = fbm(p + vec2(t * 0.2, -t * 0.15));
    float field = f1 * 0.3; // much more subtle field influence

    // Combine: height is primary, field adds variation, anomaly shifts distribution
    float value = h * 0.25 + field + an * 0.7 + cum * 0.3;
    value = 0.5 + 0.5 * value;
    value = clamp(value, 0.0, 1.0);

    // Rich blue → purple → red gradient
    vec3 cCold = vec3(0.05, 0.05, 0.6);
    vec3 cMid  = vec3(0.42, 0.05, 0.55);
    vec3 cHot  = vec3(1.0, 0.18, 0.1);

    vec3 baseCol;
    if (value < 0.5) {
        float tMid = smoothstep(0.0, 0.5, value);
        baseCol = mix(cCold, cMid, tMid);
    } else {
        float tHot = smoothstep(0.5, 1.0, value);
        baseCol = mix(cMid, cHot, tHot);
    }

    // 3D lighting - soft matte tulle fabric look
    vec3 N = normalize(v_normal);
    vec3 L = normalize(u_lightDir);
    vec3 V = normalize(u_camPos - v_pos);

    // Very soft diffuse lighting with high ambient (fabric doesn't reflect directionally)
    float lambert = max(dot(N,L), 0.0);
    
    // No specular - tulle is completely matte
    float spec = 0.0;
    
    // No rim light - avoid any glossy appearance
    float rim = 0.0;

    // High ambient light for soft fabric appearance
    vec3 col = baseCol * (0.7 + 0.3*lambert);

    // Vignette
    float vignette = smoothstep(0.9, 0.1, length(uv));
    col *= mix(0.65, 1.0, vignette);

    // Grain
    float grain = fract(sin(dot(gl_FragCoord.xy, vec2(12.9898,78.233))) * 43758.5453);
    col += (grain - 0.5) * 0.02;

    // Tulle transparency - varies with surface angle, position, and bunching
    // More transparent at grazing angles (like real fabric)
    float fresnel = pow(1.0 - abs(dot(N,V)), 2.0);
    
    // Add variation in opacity based on surface height (bunched areas more opaque)
    float heightOpacity = smoothstep(-0.3, 0.3, v_pos.y);
    
    // Spatial variation - some areas naturally less transparent (fabric density)
    float densityNoise = snoise(uv * 3.0 + vec2(u_time * 0.1, 0.0));
    float density = 0.5 + 0.5 * densityNoise;
    
    // Combine factors: base transparency + fresnel + height bunching + density
    float alpha = mix(0.4, 0.9, fresnel * 0.5 + heightOpacity * 0.3 + density * 0.2);
    
    gl_FragColor = vec4(col, alpha);
}
</script>

<script>
(() => {
  const CSV_FILE = 'yearly_climate_summary.csv';
  const BASELINE = [1945, 1975];

  const canvas = document.getElementById('glCanvas');
  const paper  = document.getElementById('paper');
  const yearLabel = document.getElementById('yearLabel');
  const exportBtn = document.getElementById('exportBtn');
  const pauseBtn = document.getElementById('pauseBtn');

  const gl = canvas.getContext('webgl', { antialias: true, preserveDrawingBuffer: true });
  if (!gl) { alert('WebGL not supported'); return; }

  // --- helpers ---
  const compile = (type, src) => {
    const sh = gl.createShader(type);
    gl.shaderSource(sh, src);
    gl.compileShader(sh);
    if (!gl.getShaderParameter(sh, gl.COMPILE_STATUS)) {
      console.error(gl.getShaderInfoLog(sh));
      throw new Error('Shader compile failed');
    }
    return sh;
  };
  const link = (vs, fs) => {
    const p = gl.createProgram();
    gl.attachShader(p, vs); gl.attachShader(p, fs); gl.linkProgram(p);
    if (!gl.getProgramParameter(p, gl.LINK_STATUS)) {
      console.error(gl.getProgramInfoLog(p)); throw new Error('Link failed');
    }
    return p;
  };

  const vs = compile(gl.VERTEX_SHADER, document.getElementById('vs').textContent);
  const fs = compile(gl.FRAGMENT_SHADER, document.getElementById('fs').textContent);
  const prog = link(vs, fs); gl.useProgram(prog);

  // --- mesh (interleaved: UV only; positions rebuilt in shader) ---
  const RES_X = 240, RES_Y = 156;                 // smooth cloth
  const verts = new Float32Array((RES_X+1)*(RES_Y+1)*2);
  let ptr = 0;
  for (let j=0; j<=RES_Y; j++){
    for (let i=0; i<=RES_X; i++){
      verts[ptr++] = i/RES_X;                     // u
      verts[ptr++] = j/RES_Y;                     // v
    }
  }
  const indices = new Uint16Array(RES_X*RES_Y*6);
  let k = 0;
  for (let j=0; j<RES_Y; j++){
    for (let i=0; i<RES_X; i++){
      const a = j*(RES_X+1)+i;
      const b = a+1;
      const c = a+(RES_X+1);
      const d = c+1;
      indices[k++] = a; indices[k++] = c; indices[k++] = b;
      indices[k++] = b; indices[k++] = c; indices[k++] = d;
    }
  }

  const vBuf = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, vBuf);
  gl.bufferData(gl.ARRAY_BUFFER, verts, gl.STATIC_DRAW);
  const iBuf = gl.createBuffer(); gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, iBuf);
  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

  const locUV = gl.getAttribLocation(prog,'aUV');
  gl.enableVertexAttribArray(locUV);
  gl.vertexAttribPointer(locUV, 2, gl.FLOAT, false, 2*4, 0);

  // uniforms
  const uProj = gl.getUniformLocation(prog,'u_proj');
  const uView = gl.getUniformLocation(prog,'u_view');
  const uTime = gl.getUniformLocation(prog,'u_time');
  const uAnom = gl.getUniformLocation(prog,'u_anomaly');
  const uCum  = gl.getUniformLocation(prog,'u_cumulative');
  const uH    = gl.getUniformLocation(prog,'u_heightScale');
  const uLight= gl.getUniformLocation(prog,'u_lightDir');
  const uCam  = gl.getUniformLocation(prog,'u_camPos');
  const uWind = gl.getUniformLocation(prog,'u_wind');
  const uPrecip = gl.getUniformLocation(prog,'u_precip');

  // camera/orbit
  let camR=28, camTheta=0.9, camPhi=0.85;
  const camPos = () => [
    camR*Math.sin(camTheta)*Math.sin(camPhi),
    camR*Math.cos(camTheta),
    camR*Math.sin(camTheta)*Math.cos(camPhi)
  ];

  // minimal mat4
  const mat4 = {
    perspective:(fovy,aspect,near,far)=>{
      const f=1/Math.tan(fovy/2), nf=1/(near-far);
      return new Float32Array([ f/aspect,0,0,0, 0,f,0,0, 0,0,(far+near)*nf,-1, 0,0,(2*far*near)*nf,0 ]);
    },
    lookAt:(eye,center,up)=>{
      let [ex,ey,ez]=eye,[cx,cy,cz]=center,[ux,uy,uz]=up;
      let zx=ex-cx, zy=ey-cy, zz=ez-cz;
      let rl=1/Math.hypot(zx,zy,zz); zx*=rl; zy*=rl; zz*=rl;
      let xx=uy*zz-uz*zy, xy=uz*zx-ux*zz, xz=ux*zy-uy*zx;
      rl=1/Math.hypot(xx,xy,xz); xx*=rl; xy*=rl; xz*=rl;
      let yx=zy*xz-zz*xy, yy=zz*xx-zx*xz, yz=zx*xy-zy*xx;
      return new Float32Array([
        xx,yx,zx,0,  xy,yy,zy,0,  xz,yz,zz,0,
        -(xx*ex+xy*ey+xz*ez),-(yx*ex+yy*ey+yz*ez),-(zx*ex+zy*ey+zz*ez),1
      ]);
    }
  };

  function fit(){
    const w = paper.clientWidth, h = paper.clientHeight;
    if (canvas.width!==w || canvas.height!==h){ canvas.width=w; canvas.height=h; gl.viewport(0,0,w,h); }
    gl.uniformMatrix4fv(uProj,false, mat4.perspective(45*Math.PI/180, w/h, 0.1, 1000));
  }
  new ResizeObserver(fit).observe(paper);

  // mouse orbit
  let dragging=false,lastX=0,lastY=0;
  paper.addEventListener('mousedown',e=>{dragging=true; lastX=e.clientX; lastY=e.clientY;});
  window.addEventListener('mouseup',()=>dragging=false);
  window.addEventListener('mousemove',e=>{
    if(!dragging) return;
    const dx=(e.clientX-lastX)*0.005, dy=(e.clientY-lastY)*0.005;
    camPhi -= dx; camTheta = Math.min(1.45, Math.max(0.2, camTheta+dy));
    lastX=e.clientX; lastY=e.clientY;
  });
  paper.addEventListener('wheel',e=>{
    e.preventDefault();
    camR = Math.min(60, Math.max(10, camR + e.deltaY*0.01));
  }, {passive:false});

  // CSV -> yearly anomalies (using pre-calculated yearly_climate_summary.csv)
  let years=[], anomaliesNorm=[], cumulativeNorm=[], windNorm=[], precipNorm=[];
  fetch(CSV_FILE).then(r=>{ if(!r.ok) throw new Error('CSV missing'); return r.text(); })
    .then(text=>{
      const lines=text.trim().split(/\r?\n/);
      const yearlyData=[];
      
      // Parse yearly summary CSV (year,temp,temp_anomaly,wind,precip,humidity)
      for(let i=1;i<lines.length;i++){
        const c=lines[i].split(',');
        if(c.length<5) continue;
        const year = parseInt(c[0],10);
        const anomaly = parseFloat(c[2]); // temp_anomaly column
        const wind = parseFloat(c[3]);    // wind column
        const precip = parseFloat(c[4]);  // precip column
        if(Number.isFinite(year) && Number.isFinite(anomaly) && Number.isFinite(wind) && Number.isFinite(precip)) {
          yearlyData.push({year, anomaly, wind, precip});
        }
      }
      
      years = yearlyData.map(d=>d.year);
      const rawAnom = yearlyData.map(d=>d.anomaly);
      const rawWind = yearlyData.map(d=>d.wind);
      const rawPrecip = yearlyData.map(d=>d.precip);
      
      // Normalize anomalies to 0–1
      const aMin=Math.min(...rawAnom), aMax=Math.max(...rawAnom), span=(aMax-aMin)||1;
      anomaliesNorm = rawAnom.map(a=>(a-aMin)/span);
      
      // Cumulative anomalies (running sum) then normalize
      const cum=[]; let acc=0; 
      for(const a of rawAnom){ acc+=a; cum.push(acc); }
      const cMin=Math.min(...cum), cMax=Math.max(...cum), cSpan=(cMax-cMin)||1;
      cumulativeNorm = cum.map(v=>(v-cMin)/cSpan);
      
      // Normalize wind and precipitation to 0–1
      const wMin=Math.min(...rawWind), wMax=Math.max(...rawWind), wSpan=(wMax-wMin)||1;
      windNorm = rawWind.map(w=>(w-wMin)/wSpan);
      
      const pMin=Math.min(...rawPrecip), pMax=Math.max(...rawPrecip), pSpan=(pMax-pMin)||1;
      precipNorm = rawPrecip.map(p=>(p-pMin)/pSpan);
      
      start();
    })
    .catch(e=>{ yearLabel.textContent='Error: CSV not found'; console.error(e); });

  // animation (blend between years)
  const SEC_PER_YEAR = 1.25;
  let yearIdx=0, blend=0, lastT=performance.now()/1000;
  let isPaused = false;
  let currentAnom, currentCum, currentWind, currentPrecip, currentTime;

  // Restart button (reset to 1945)
  const restartBtn = document.getElementById('restartBtn');
  restartBtn.addEventListener('click', ()=>{
    yearIdx = 0;
    blend = 0;
    isPaused = false;
    lastT = performance.now()/1000;
    pauseBtn.textContent = 'Pause';
    pauseBtn.classList.remove('bg-sky-600','bg-sky-500');
    pauseBtn.classList.add('bg-zinc-700');
    // update label immediately
    if (years.length) yearLabel.textContent = `Year: ${years[0]}`;
  });

  function start(){ fit(); requestAnimationFrame(tick); }

  function tick(){
    const now=performance.now()/1000, dt=isPaused ? 0 : now-lastT; 
    lastT=now;

    const lastIdx=anomaliesNorm.length-1;
    if(yearIdx<lastIdx){ blend += dt/SEC_PER_YEAR; if(blend>=1){ blend=0; yearIdx++; } }
    const ia=yearIdx, ib=Math.min(yearIdx+1,lastIdx);
    currentAnom = anomaliesNorm[ia]*(1-blend) + anomaliesNorm[ib]*blend;
    currentCum  = cumulativeNorm[ia]*(1-blend) + cumulativeNorm[ib]*blend;
    currentWind = windNorm[ia]*(1-blend) + windNorm[ib]*blend;
    currentPrecip = precipNorm[ia]*(1-blend) + precipNorm[ib]*blend;
    currentTime = now;
    const yDisp= Math.round(years[ia]*(1-blend) + years[ib]*blend);
    yearLabel.textContent = `Year: ${yDisp}`;

    draw(currentTime, currentAnom, currentCum, currentWind, currentPrecip);
    requestAnimationFrame(tick);
  }

  function draw(t, anomaly, cumulative, wind, precip){
    fit();
    gl.clearColor(0.02,0.02,0.04,1);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    gl.enable(gl.DEPTH_TEST);
    gl.depthMask(true);               // write to depth buffer
    
    // Enable transparency blending for tulle effect
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
    
    gl.disable(gl.CULL_FACE);         // render both sides for transparency

    const eye = camPos();
    gl.uniformMatrix4fv(uView,false, mat4.lookAt(eye,[0,0,0],[0,1,0]));
    gl.uniform3fv(uCam, new Float32Array(eye));
    gl.uniform3fv(uLight, new Float32Array([0.4,0.8,0.3]));
    gl.uniform1f(uTime, t);
    gl.uniform1f(uAnom, anomaly);
    gl.uniform1f(uCum, cumulative);
    gl.uniform1f(uWind, wind);
    gl.uniform1f(uPrecip, precip);
    gl.uniform1f(uH, 4.0);             // raise for more dramatic depth

    gl.bindBuffer(gl.ARRAY_BUFFER, vBuf);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, iBuf);
    gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);
  }

  // Pause/Resume button
  pauseBtn.addEventListener('click', ()=>{
    isPaused = !isPaused;
    pauseBtn.textContent = isPaused ? 'Resume' : 'Pause';
    pauseBtn.classList.toggle('bg-zinc-700', !isPaused);
    pauseBtn.classList.toggle('bg-zinc-600', !isPaused);
    pauseBtn.classList.toggle('bg-sky-600', isPaused);
    pauseBtn.classList.toggle('bg-sky-500', isPaused);
  });

  // high-res export 17×11 @ 300DPI - top-down view of current year
  exportBtn.addEventListener('click', ()=>{
    // Save current camera state
    const prevW=canvas.width, prevH=canvas.height;
    const prevCamR = camR, prevCamTheta = camTheta, prevCamPhi = camPhi;
    
    // Set up export resolution and camera
    const W=5100, H=3300;
    canvas.width=W; canvas.height=H; gl.viewport(0,0,W,H);
    
    // Top-down orthographic view
    const aspect = W/H;
    const height = 6.5; // vertical world units visible
    const width = height * aspect;
    const ortho = new Float32Array([
      2/width, 0, 0, 0,
      0, 2/height, 0, 0,
      0, 0, -2/(1000-0.1), 0,
      0, 0, -(1000+0.1)/(1000-0.1), 1
    ]);
    gl.uniformMatrix4fv(uProj, false, ortho);
    
    // Top-down camera position and view
    const topDownView = mat4.lookAt([0, 25, 0], [0, 0, 0], [0, 0, -1]);
    gl.uniformMatrix4fv(uView, false, topDownView);
    gl.uniform3fv(uCam, new Float32Array([0, 25, 0]));
    
    // Draw current paused frame (or last frame if not paused)
    const exportTime = isPaused ? currentTime : performance.now()/1000;
    const exportAnom = currentAnom !== undefined ? currentAnom : anomaliesNorm[anomaliesNorm.length-1];
    const exportCum = currentCum !== undefined ? currentCum : cumulativeNorm[cumulativeNorm.length-1];
    const exportWind = currentWind !== undefined ? currentWind : windNorm[windNorm.length-1];
    const exportPrecip = currentPrecip !== undefined ? currentPrecip : precipNorm[precipNorm.length-1];
    
    // Clear and draw with export settings
    gl.clearColor(0.02,0.02,0.04,1);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    gl.enable(gl.DEPTH_TEST);
    gl.depthMask(true);
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
    gl.disable(gl.CULL_FACE);
    
    gl.uniform3fv(uLight, new Float32Array([0.4,0.8,0.3]));
    gl.uniform1f(uTime, exportTime);
    gl.uniform1f(uAnom, exportAnom);
    gl.uniform1f(uCum, exportCum);
    gl.uniform1f(uWind, exportWind);
    gl.uniform1f(uPrecip, exportPrecip);
    gl.uniform1f(uH, 4.0);
    
    gl.bindBuffer(gl.ARRAY_BUFFER, vBuf);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, iBuf);
    gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);
    
    // Export canvas as PNG
    const a=document.createElement('a');
    a.download='philadelphia_climate_surface_17x11_300dpi.png';
    a.href=canvas.toDataURL('image/png'); 
    a.click();
    
    // Restore previous state
    canvas.width=prevW; canvas.height=prevH; 
    gl.viewport(0,0,prevW,prevH);
    camR = prevCamR; camTheta = prevCamTheta; camPhi = prevCamPhi;
    fit();
  });
})();
</script>
</body>
</html>
