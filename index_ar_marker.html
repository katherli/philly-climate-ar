<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Philadelphia Climate Surface AR - Image Marker</title>

<!-- MindAR + A-Frame -->
<script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.2/dist/mindar-image.prod.js"></script>
<script src="https://aframe.io/releases/1.4.2/aframe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.2/dist/mindar-image-aframe.prod.js"></script>

<style>
  html, body { margin:0; padding:0; overflow:hidden; font-family:Inter,system-ui,sans-serif; }
  #instructions {
    position:absolute; top:20px; left:50%; transform:translateX(-50%);
    background:rgba(0,0,0,0.75); color:white; padding:15px 25px;
    border-radius:12px; font-size:14px; z-index:1000; text-align:center;
    backdrop-filter:blur(10px);
  }
  #yearLabel {
    position:absolute; bottom:20px; left:50%; transform:translateX(-50%);
    background:rgba(0,0,0,0.75); color:#38bdf8; padding:10px 20px;
    border-radius:8px; font-size:12px; font-family:monospace; z-index:1000;
    backdrop-filter:blur(10px);
  }
</style>
</head>
<body>
  <div id="instructions">Point camera at the purple Earth marker</div>
  <div id="yearLabel">Loading…</div>

  <a-scene
    mindar-image="imageTargetSrc: ./marker.mind; autoStart: true; uiLoading: no; uiError: no; uiScanning: no;"
    color-space="sRGB"
    renderer="colorManagement: true, physicallyCorrectLights"
    vr-mode-ui="enabled: false"
    device-orientation-permission-ui="enabled: false">

    <a-assets>
      <!-- keep your shader assets as-is -->
      <a-asset-item id="shaderVert" src="#vertexShader"></a-asset-item>
      <a-asset-item id="shaderFrag" src="#fragmentShader"></a-asset-item>
    </a-assets>

    <!-- MindAR camera -->
    <a-camera position="0 0 0" look-controls="enabled: false"></a-camera>

    <!-- Attach your fabric to the *first* (and only) image target -->
    <a-entity mindar-image-target="targetIndex: 0">
      <a-entity
        id="climateFabric"
        position="0 0 0"
        rotation="-90 0 0"
        scale="1 1 1"
        climate-fabric>
      </a-entity>
    </a-entity>
  </a-scene>

  <!-- MindAR debug helpers: fetch marker.mind, log MindAR lifecycle and target events -->
  <script>
  (function(){
    const markerUrl = './marker.mind';
    console.log('[AR DEBUG] beginning marker diagnostic');

    // Check marker file fetch
    fetch(markerUrl).then(r => {
      console.log('[AR DEBUG] fetch marker.mind status:', r.status, r.statusText);
      return r.arrayBuffer();
    }).then(buf => {
      console.log('[AR DEBUG] marker.mind size (bytes):', buf.byteLength);
    }).catch(err => {
      console.error('[AR DEBUG] failed to fetch marker.mind:', err);
    });

    // Wait until scene is ready
    window.addEventListener('load', ()=>{
      const scene = document.querySelector('a-scene');
      if(!scene){ console.warn('[AR DEBUG] a-scene not found'); return; }

      // MindAR component instance
      const mindarComp = scene.components && scene.components['mindar-image'];
      console.log('[AR DEBUG] mindar-image component present?', !!mindarComp, mindarComp);

      // Listen for MindAR start/stop/error via the scene's system
      scene.addEventListener('mindar-initialized', ()=> console.log('[AR DEBUG] mindar-initialized'));
      scene.addEventListener('mindar-start', ()=> console.log('[AR DEBUG] mindar-start'));
      scene.addEventListener('mindar-stop', ()=> console.log('[AR DEBUG] mindar-stop'));
      scene.addEventListener('mindar-error', (e)=> console.error('[AR DEBUG] mindar-error', e));

      // Attach target events
      const target = document.querySelector('[mindar-image-target]');
      if(!target){ console.warn('[AR DEBUG] mindar-image-target entity not found'); return; }
      target.addEventListener('targetFound', (e)=> console.log('[AR DEBUG] targetFound', e));
      target.addEventListener('targetLost',  (e)=> console.log('[AR DEBUG] targetLost', e));

      console.log('[AR DEBUG] debug hooks installed');
    });
  })();
  </script>

  <!-- Vertex shader: 17×11 plane displaced like cloth/water -->
  <script id="vertexShader" type="x-shader/x-vertex">
attribute vec2 aUV;

uniform mat4 u_proj, u_view;
uniform float u_time;
uniform float u_anomaly;
uniform float u_cumulative;
uniform float u_heightScale;
uniform float u_wind;
uniform float u_precip;

varying vec3 v_pos;
varying vec3 v_normal;
varying vec2 v_uv;
varying float v_anom;

mat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,-s,s,c);}

vec3 permute(vec3 x){ return mod(((x*34.0)+1.0)*x, 289.0); }

float snoise(vec2 v){
  const vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);
  vec2 i  = floor(v + dot(v, C.yy));
  vec2 x0 = v - i + dot(i, C.xx);
  vec2 i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
  vec4 x12 = x0.xyxy + C.xxzz;
  x12.xy -= i1;
  i = mod(i, 289.0);
  vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0)) + i.x + vec3(0.0, i1.x, 1.0));
  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
  m = m*m; m = m*m;
  vec3 x = 2.0 * fract(p * C.www) - 1.0;
  vec3 h = abs(x) - 0.5;
  vec3 ox = floor(x + 0.5);
  vec3 a0 = x - ox;
  m *= 1.79284291400159 - 0.85373472095314 * (a0*a0 + h*h);
  vec3 g;
  g.x  = a0.x  * x0.x  + h.x  * x0.y;
  g.yz = a0.yz * x12.xz + h.yz * x12.yw;
  return 130.0 * dot(m, g);
}

float disp(vec2 p, float t, float an, float cum, float wind, float precip){
  float A = mix(0.05, 0.25, an) + cum * 0.12;
  
  vec2 noiseCoord = p * 0.2;
  float n1 = snoise(noiseCoord + vec2(t*0.1, 0.0));
  float n2 = snoise(noiseCoord * 1.3 - vec2(0.0, t*0.15));
  
  float localPhase = (n1 + n2) * 0.5;
  float localAmp = 0.7 + 0.3 * snoise(p * 0.15 + t * 0.08);
  
  float k1 = mix(0.6, 0.4, an), sp1 = 0.8 + wind * 0.15;
  float k2 = mix(0.8, 0.6, an), sp2 = 1.0 + wind * 0.2;
  float k3 = mix(0.9, 0.7, an), sp3 = 0.6 + wind * 0.1;

  vec2 q1 = rot(0.00)  * p; 
  float w1 = sin(dot(q1, vec2(k1, k1*1.05)) - t*sp1 + localPhase*0.3);
  
  vec2 q2 = rot(2.09)  * p;
  float w2 = sin(dot(q2, vec2(k2, k2*1.05)) - t*sp2 + localPhase*0.3);
  
  vec2 q3 = rot(4.19) * p;
  float w3 = sin(dot(q3, vec2(k3, k3*1.05)) - t*sp3 + localPhase*0.3);
  
  return A * localAmp * (w1 + 0.8*w2 + 0.6*w3);
}

void main(){
  v_uv = aUV;
  v_anom = u_anomaly;

  vec2 plane = vec2(mix(-8.5, 8.5, aUV.x), mix(-5.5, 5.5, aUV.y));

  float t = u_time;
  
  float billow1 = sin(plane.x * 0.3 + t * 0.4) * cos(plane.y * 0.25 + t * 0.35);
  float billow2 = sin(plane.x * 0.4 - plane.y * 0.3 + t * 0.5);
  float billowHeight = (billow1 * 0.8 + billow2 * 0.5) * 0.3;
  
  float h  = disp(plane, t, u_anomaly, u_cumulative, u_wind, u_precip) + billowHeight;

  float e = 0.05;
  float billow1x = sin((plane.x+e) * 0.3 + t * 0.4) * cos(plane.y * 0.25 + t * 0.35);
  float billow2x = sin((plane.x+e) * 0.4 - plane.y * 0.3 + t * 0.5);
  float billowHeightX = (billow1x * 0.8 + billow2x * 0.5) * 0.3;
  
  float billow1y = sin(plane.x * 0.3 + t * 0.4) * cos((plane.y+e) * 0.25 + t * 0.35);
  float billow2y = sin(plane.x * 0.4 - (plane.y+e) * 0.3 + t * 0.5);
  float billowHeightY = (billow1y * 0.8 + billow2y * 0.5) * 0.3;
  
  float hx = disp(plane + vec2(e,0.0), t, u_anomaly, u_cumulative, u_wind, u_precip) + billowHeightX;
  float hy = disp(plane + vec2(0.0,e), t, u_anomaly, u_cumulative, u_wind, u_precip) + billowHeightY;

  vec3 P  = vec3(plane.x, h*u_heightScale, plane.y);
  vec3 Px = vec3(plane.x+e, hx*u_heightScale, plane.y);
  vec3 Py = vec3(plane.x, hy*u_heightScale, plane.y+e);

  vec3 N = normalize(cross(Py-P, Px-P));

  v_pos = P;
  v_normal = N;

  gl_Position = u_proj * u_view * vec4(P,1.0);
}
  </script>

  <!-- Fragment shader: color mapping + lighting -->
  <script id="fragmentShader" type="x-shader/x-fragment">
precision highp float;

varying vec3 v_pos;
varying vec3 v_normal;
varying vec2 v_uv;
varying float v_anom;

uniform vec3 u_lightDir;
uniform vec3 u_camPos;
uniform float u_time;
uniform float u_cumulative;

vec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }

float snoise(vec2 v) {
    const vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);
    vec2 i  = floor(v + dot(v, C.yy));
    vec2 x0 = v - i + dot(i, C.xx);
    vec2 i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
    vec4 x12 = x0.xyxy + C.xxzz;
    x12.xy -= i1;
    i = mod(i, 289.0);
    vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0)) + i.x + vec3(0.0, i1.x, 1.0));
    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
    m = m*m; m = m*m;
    vec3 x = 2.0 * fract(p * C.www) - 1.0;
    vec3 h = abs(x) - 0.5;
    vec3 ox = floor(x + 0.5);
    vec3 a0 = x - ox;
    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0 + h*h);
    vec3 g;
    g.x  = a0.x  * x0.x  + h.x  * x0.y;
    g.yz = a0.yz * x12.xz + h.yz * x12.yw;
    return 130.0 * dot(m, g);
}

float fbm(vec2 p) {
    float v = 0.0;
    float a = 0.5;
    float freq = 1.0;
    for (int i = 0; i < 5; i++) {
        v += a * snoise(p * freq);
        freq *= 2.0;
        a *= 0.5;
    }
    return v;
}

void main(){
    vec2 uv = v_uv - 0.5;
    float aspect = 17.0 / 11.0;
    uv.x *= aspect;

    float an = v_anom * 2.0 - 1.0;
    float cum = u_cumulative * 2.0 - 1.0;

    float speed = mix(0.15, 0.6, clamp(u_cumulative, 0.0, 1.0));
    float t = u_time * speed;

    float h = v_pos.y;
    
    vec2 base = uv * mix(1.8, 2.5, 0.5 + 0.5*an);
    vec2 warp = vec2(
        snoise(base * 0.5 + vec2(0.0, t*0.3)),
        snoise(base * 0.5 + vec2(t*0.3, 1.0))
    );
    vec2 p = base + warp * 0.3;

    float f1 = fbm(p + vec2(t * 0.2, -t * 0.15));
    float field = f1 * 0.3;

    float value = h * 0.25 + field + an * 0.7 + cum * 0.3;
    value = 0.5 + 0.5 * value;
    value = clamp(value, 0.0, 1.0);

    vec3 cCold = vec3(0.05, 0.05, 0.6);
    vec3 cMid  = vec3(0.42, 0.05, 0.55);
    vec3 cHot  = vec3(1.0, 0.18, 0.1);

    vec3 baseCol;
    if (value < 0.5) {
        float tMid = smoothstep(0.0, 0.5, value);
        baseCol = mix(cCold, cMid, tMid);
    } else {
        float tHot = smoothstep(0.5, 1.0, value);
        baseCol = mix(cMid, cHot, tHot);
    }

    vec3 N = normalize(v_normal);
    vec3 L = normalize(u_lightDir);
    vec3 V = normalize(u_camPos - v_pos);

    float lambert = max(dot(N,L), 0.0);
    
    vec3 col = baseCol * (0.7 + 0.3*lambert);

    float vignette = smoothstep(0.9, 0.1, length(uv));
    col *= mix(0.65, 1.0, vignette);

    float grain = fract(sin(dot(gl_FragCoord.xy, vec2(12.9898,78.233))) * 43758.5453);
    col += (grain - 0.5) * 0.02;

    float fresnel = pow(1.0 - abs(dot(N,V)), 2.0);
    float heightOpacity = smoothstep(-0.3, 0.3, v_pos.y);
    float densityNoise = snoise(uv * 3.0 + vec2(u_time * 0.1, 0.0));
    float density = 0.5 + 0.5 * densityNoise;
    
    float alpha = mix(0.4, 0.9, fresnel * 0.5 + heightOpacity * 0.3 + density * 0.2);
    
    gl_FragColor = vec4(col, alpha);
}
  </script>

  <!-- Climate fabric A-Frame component -->
  <script>
AFRAME.registerComponent('climate-fabric', {
  schema: {},
  
  init: function() {
    const CSV_FILE = 'yearly_climate_summary.csv';
    const BASELINE = [1945, 1975];
    
    this.years = [];
    this.anomaliesNorm = [];
    this.cumulativeNorm = [];
    this.windNorm = [];
    this.precipNorm = [];
    this.yearIdx = 0;
    this.blend = 0;
    this.lastT = Date.now() / 1000;
    
    const yearLabel = document.getElementById('yearLabel');
    
    // Load CSV data
    fetch(CSV_FILE)
      .then(r => { if(!r.ok) throw new Error('CSV missing'); return r.text(); })
      .then(text => {
        const lines = text.trim().split(/\r?\n/);
        const yearlyData = [];
        
        for(let i=1; i<lines.length; i++) {
          const c = lines[i].split(',');
          if(c.length<5) continue;
          const year = parseInt(c[0],10);
          const anomaly = parseFloat(c[2]);
          const wind = parseFloat(c[3]);
          const precip = parseFloat(c[4]);
          if(Number.isFinite(year) && Number.isFinite(anomaly) && Number.isFinite(wind) && Number.isFinite(precip)) {
            yearlyData.push({year, anomaly, wind, precip});
          }
        }
        
        this.years = yearlyData.map(d => d.year);
        const rawAnom = yearlyData.map(d => d.anomaly);
        const rawWind = yearlyData.map(d => d.wind);
        const rawPrecip = yearlyData.map(d => d.precip);
        
        const aMin = Math.min(...rawAnom), aMax = Math.max(...rawAnom), span = (aMax-aMin)||1;
        this.anomaliesNorm = rawAnom.map(a => (a-aMin)/span);
        
        const cum = []; let acc = 0;
        for(const a of rawAnom) { acc += a; cum.push(acc); }
        const cMin = Math.min(...cum), cMax = Math.max(...cum), cSpan = (cMax-cMin)||1;
        this.cumulativeNorm = cum.map(v => (v-cMin)/cSpan);
        
        const wMin = Math.min(...rawWind), wMax = Math.max(...rawWind), wSpan = (wMax-wMin)||1;
        this.windNorm = rawWind.map(w => (w-wMin)/wSpan);
        
        const pMin = Math.min(...rawPrecip), pMax = Math.max(...rawPrecip), pSpan = (pMax-pMin)||1;
        this.precipNorm = rawPrecip.map(p => (p-pMin)/pSpan);
        
        // Create custom shader material
        this.createMaterial();
      })
      .catch(e => { yearLabel.textContent = 'Error loading data'; console.error(e); });
  },
  
  createMaterial: function() {
    const RES_X = 240, RES_Y = 156;
    const verts = new Float32Array((RES_X+1)*(RES_Y+1)*2);
    let ptr = 0;
    for (let j=0; j<=RES_Y; j++) {
      for (let i=0; i<=RES_X; i++) {
        verts[ptr++] = i/RES_X;
        verts[ptr++] = j/RES_Y;
      }
    }
    
    const indices = new Uint16Array(RES_X*RES_Y*6);
    let k = 0;
    for (let j=0; j<RES_Y; j++) {
      for (let i=0; i<RES_X; i++) {
        const a = j*(RES_X+1)+i;
        const b = a+1;
        const c = a+(RES_X+1);
        const d = c+1;
        indices[k++] = a; indices[k++] = c; indices[k++] = b;
        indices[k++] = b; indices[k++] = c; indices[k++] = d;
      }
    }
    
    const geometry = new THREE.BufferGeometry();
    geometry.setAttribute('aUV', new THREE.BufferAttribute(verts, 2));
    geometry.setIndex(new THREE.BufferAttribute(indices, 1));
    
    const vertShader = document.getElementById('vertexShader').textContent;
    const fragShader = document.getElementById('fragmentShader').textContent;
    
    this.material = new THREE.ShaderMaterial({
      vertexShader: vertShader,
      fragmentShader: fragShader,
      uniforms: {
        u_proj: { value: new THREE.Matrix4() },
        u_view: { value: new THREE.Matrix4() },
        u_time: { value: 0 },
        u_anomaly: { value: 0 },
        u_cumulative: { value: 0 },
        u_heightScale: { value: 4.0 },
        u_wind: { value: 0 },
        u_precip: { value: 0 },
        u_lightDir: { value: new THREE.Vector3(0.4, 0.8, 0.3).normalize() },
        u_camPos: { value: new THREE.Vector3(0, 0, 0) }
      },
      transparent: true,
      side: THREE.DoubleSide,
      depthWrite: false
    });
    
    const mesh = new THREE.Mesh(geometry, this.material);
    this.el.setObject3D('mesh', mesh);
  },
  
  tick: function(time, deltaTime) {
    if (!this.material || this.years.length === 0) return;
    
    const SEC_PER_YEAR = 1.25;
    const now = Date.now() / 1000;
    const dt = now - this.lastT;
    this.lastT = now;
    
    const lastIdx = this.anomaliesNorm.length - 1;
    if (this.yearIdx < lastIdx) {
      this.blend += dt / SEC_PER_YEAR;
      if (this.blend >= 1) {
        this.blend = 0;
        this.yearIdx++;
      }
    }
    
    const ia = this.yearIdx, ib = Math.min(this.yearIdx + 1, lastIdx);
    const currentAnom = this.anomaliesNorm[ia] * (1-this.blend) + this.anomaliesNorm[ib] * this.blend;
    const currentCum = this.cumulativeNorm[ia] * (1-this.blend) + this.cumulativeNorm[ib] * this.blend;
    const currentWind = this.windNorm[ia] * (1-this.blend) + this.windNorm[ib] * this.blend;
    const currentPrecip = this.precipNorm[ia] * (1-this.blend) + this.precipNorm[ib] * this.blend;
    
    const yDisp = Math.round(this.years[ia] * (1-this.blend) + this.years[ib] * this.blend);
    const yearLabel = document.getElementById('yearLabel');
    if (yearLabel) yearLabel.textContent = `Year: ${yDisp}`;
    
    // Update uniforms
    this.material.uniforms.u_time.value = now;
    this.material.uniforms.u_anomaly.value = currentAnom;
    this.material.uniforms.u_cumulative.value = currentCum;
    this.material.uniforms.u_wind.value = currentWind;
    this.material.uniforms.u_precip.value = currentPrecip;
    
    // Update camera and projection uniforms
    const camera = this.el.sceneEl.camera;
    if (camera) {
      this.material.uniforms.u_proj.value.copy(camera.projectionMatrix);
      this.material.uniforms.u_view.value.copy(camera.matrixWorldInverse);
      this.material.uniforms.u_camPos.value.setFromMatrixPosition(camera.matrixWorld);
    }
  }
});
  </script>
</body>
</html>
